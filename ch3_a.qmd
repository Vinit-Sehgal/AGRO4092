---
title-block-banner: true
bibliography: references.bib
editor: 
  markdown: 
    wrap: sentence
---

## Raster Arithmetic Operations 

Arithmetic, comparison and logical operations on `SpatRasters` use the same operators as those used for simple vector-like operations.
These operators are listed below:

**a) Arithmetic operators**

![](images/clipboard-3782266917.png){width="336"}

**b) Comparison operators**

![](images/clipboard-1580357337.png){width="331"}

**c) Logical operators**

![](images/clipboard-582905687.png){width="331"}

------------------------------------------------------------------------

The application of these operators on rasters can be conceptualized as element-wise operations on a matrix.
For example, assume ***A*** is a raster with values shown in the matrix form as below:

![](images/clipboard-120741885.png){width="300"}

Then, ***A*** + 1 will be:

![](images/clipboard-867285346.png){width="400"}

Note how each element of the matrix gets an addition of 1.
Similarly, for ***A*** x 2, each element of ***A*** will be multiplied by 2 as:

![](images/clipboard-4015941933.png){width="400"}

and, ***A*** \^ 2 will be given as:

![](images/clipboard-4103069676.png){width="400"}

Logical operations can also be carried out in a similar fashion.
For example, if we were to test if the cell values of ***A*** are greater than 3 (i.e. ***A*** \> 3), it will be written as:

![](images/clipboard-2109535833.png){width="400"}

Now let us try a few examples of arithmetic, comparison and logical operations on `SpatRasters`.
Before we begin this chapter, let us ensure that we have the sample dataset necessary for the analysis, otherwise, download the files from the GitHub repository using the following codes:

```{r, message = FALSE, warning = FALSE}
#~~~ Check if sample data exists. If not, download from GitHub repository

if (dir.exists("SampleData-master")==FALSE){ 
download.file(url = "https://github.com/Vinit-Sehgal/SampleData/archive/master.zip",
destfile = "SampleData-master.zip")    

# Unzip the downloaded .zip file
unzip(zipfile = "SampleData-master.zip")
}
list.files("./SampleData-master")   # List folder contents

```

Taking example of SMAP soil moisture raster let us practice the application of arithmetic operations on `SpatRasters`.

```{r, message = FALSE, warning = FALSE}
library(terra) # Import library

# Import SMAP soil moisture raster from the downloaded folder
sm=terra::rast("./SampleData-master/raster_files/SMAP_SM.tif")
print(sm)

# Add 1 to raster values
sm2=sm+1
print(sm2) #Notice the max and min values have increased by 1. 

# Multiply raster values by 2
sm2=sm*2
plot(sm2, main= "sm*2") # Try sm2=sm*10, or sm2=sm^2 and see the difference in sm2 values
```

Similarly, logical operations can also be carried out with ease.
Logical operators can be a convenient tool for raster data manipulation.
For example, any subset of values can be replaced, deleted based on a user-defined logical criteria.
Imagine a raster may have a fill value of -9999, it may be advisable to remove these values by replacing them with `NA` in certain cases.

Notice that some SMAP rasters used here are patchy.
Previously, we have used 3-day averaged soil moisture using rasters from individual days.
Satellites collect dataset in regularly spaced swaths as they orbit around the globe.
In the case of SMAP satellite, it takes 2-3 days to cover the entire Earth.

```{r, message = FALSE, warning = FALSE}
# Are cell values of sm raster greater than 0.3?
sm=terra::rast("./SampleData-master/raster_files/SMAP_SM.tif")
sm2=sm>0.3    
plot(sm2, main="is cell value >0.3")    # Notice that the raster has only True and False values

# Replace all values of sm>0.3 with 0.5
sm=terra::rast("./SampleData-master/raster_files/SMAP_SM.tif")
sm[sm>0.3]=0.5 
plot(sm, main="replace sm>0.3 with 0.5")

# Or replace all values of sm>0.3 with NA 
sm=terra::rast("./SampleData-master/raster_files/SMAP_SM.tif")
sm[sm>0.3]=NA 
plot(sm, main="replace sm>0.3 with NA")

# Reaplace all NA values with 0
sm=terra::rast("./SampleData-master/raster_files/SMAP_SM.tif")
sm[is.na(sm)]=0
plot(sm)

# Reaplace fill values with NA
sm=rast("./SampleData-master/raster_files/SMAP_L3_SM_P_20150401_R17000_002_Soil_Moisture_Retrieval_Data_AM_soil_moisture_867a5e36.tif")

smFilter=sm                   # Copy original raster before manipulation
smFilter[smFilter==-9999]=NA  # Replace negative values with -9999

# Plot original and manipulated raster
layout(matrix(1:2, ncol = 2))   # Specify layout for plots
plot(sm, main= "raw raster with fill values")
plot(smFilter, main="Post filtering -9999")
```

------------------------------------------------------------------------

So far we saw examples of a arithmetic/ logical operations on a single raster.
However, the tenets of arithmetic operations discussed earlier are also applicable for operations on two (or more) rasters.
These operations will be carried out cell-wise between the corresponding pixels of the rasters.
Suppose, another raster ***B*** is given as:

![](images/clipboard-582080679.png){width="300"}

then, ***A***+***B*** will be:

![](images/clipboard-3617557945.png){width="500"}

Similarly, ***A***x***B*** will also be a cell-wise multiplication of respective data values:

![](images/clipboard-3088959865.png){width="500"}

Let us now use modeled rootzone soil moisture from NASA's SMAP level 4 products for three consecutive days.

```{r, message = FALSE, warning = FALSE}

SMday1=rast("./SampleData-master/SMAPL4_rasters/SMAP_L4_SM_gph_20211213T103000_Vv6030_001_Geophysical_Data_sm_rootzone_2052db45.tif")

SMday2=rast("./SampleData-master/SMAPL4_rasters/SMAP_L4_SM_gph_20211214T103000_Vv6030_001_Geophysical_Data_sm_rootzone_22156243.tif")

SMday3=rast("./SampleData-master/SMAPL4_rasters/SMAP_L4_SM_gph_20211215T103000_Vv6030_001_Geophysical_Data_sm_rootzone_23bd7fe2.tif")

layout(matrix(1:3, ncol = 1))                # Specify layout
plot(SMday1, main="Rootzone SM day1")
plot(SMday2, main="Rootzone SM day2")
plot(SMday3, main="Rootzone SM day3")
```

Note that we can not make out the differences in the rasters as the colors are skewed by the high negative fill value for missing data in the rasters.
So, we first remove the fill values (i.e. cells valued at -9999) with `NA`.

```{r, message = FALSE, warning = FALSE}

SMday1[SMday1==-9999]=NA  # Replace negative values with -9999
SMday2[SMday2==-9999]=NA  # Replace negative values with -9999
SMday3[SMday3==-9999]=NA  # Replace negative values with -9999

layout(matrix(1:3, ncol = 1))                # Specify layout
plot(SMday1, main="SM day1, filtered")
plot(SMday2, main="SM day2, filtered")
plot(SMday3, main="SM day3, filtered")
```

Now, let's calculate the change in soil moisture values between days 1-2 and 1-3.
Can we identify a region which showed anomalous wetting during the three days of observation?

```{r, message = FALSE, warning = FALSE}
delta12=SMday1-SMday2
delta13=SMday1-SMday3

layout(matrix(1:2, ncol = 1))                # Specify layout
plot(delta12, main="SM difference (day 1 & 2")
plot(delta13, main="SM difference (day 1 & 3")
```

Curious to know why Southern California showed such high levels of wetting?
Check out: ['Storm of the season' dumps record-breaking rainfall on SoCal and snow in the mountains - Los Angeles Times (latimes.com)]('Storm of the season' dumps record-breaking rainfall on SoCal and snow in the mountains - Los Angeles Times (latimes.com))

------------------------------------------------------------------------

## Raster Statistics

We will use `global` function to apply summary statistics and user-defined operations on cells of a raster.

```{r, message = FALSE, warning = FALSE}

library(terra) 

# Import SMAP soil moisture raster from the downloaded folder
sm=terra::rast("./SampleData-master/raster_files/SMAP_SM.tif")

# Summary statistics
global(sm, mean, na.rm = T)
global(sm, sd, na.rm = T)
global(sm, quantile, probs = c(0.25, 0.75), na.rm = T)

# User-defined statistics by defining own function
quant_fun = function(x, na.rm=TRUE){ # Remember to add "na.rm" option
  quantile(x, probs = c(0.25, 0.75), na.rm=TRUE)
} 
global(sm, quant_fun)   # 25th, and 75th percentile of each layer

# Plot summary using standard statistical functions
layout(matrix(1:2, ncol = 2))                # Specify layout
hist(sm)
boxplot(sm)
```

## Raster Resampling

Raster resampling refers to changing the resolution of the raster.
The term "resampling" used here implies that the pixel values are "sampled" to the new resolution using an interpolation method (nearest neighbor, bilinear, spline, min, max, mode, average etc).
We will try three important functions for changing the resolution of a SpatRaster: `terra::aggregate` (resample from fine to coarse resolution), `terra::disagg` (resample from coarse to fine resolution) and `terra::resample` (resample to match the resolution of another raster).
The following schematic helps illustrate the use of these functions:

![](images/resampling.png)

Lets us now explore an example for raster resampling.

```{r, message = FALSE, warning = FALSE}
library(terra)

# Import SMAP soil moisture raster
sm=terra::rast("./SampleData-master/raster_files/SMAP_SM.tif") 

# Original resolution of raster for reference
res(sm)

#~~ Aggregate raster to coarser resolution
SMcoarse = terra::aggregate(sm,           # Soil moisture raster
                            fact = 10,    # Aggregate by x 10
                            fun = mean)   # Function used to aggregate values
res(SMcoarse)

#~~ Disaggregate raster to finer resolution
SMfine = terra::disagg(sm, 
                   fact=3, 
                   method='bilinear')
res(SMfine)

#~~ Raster resampling
# Import global aridity raster
aridity=rast("./SampleData-master/raster_files/aridity_36km.tif") 

# Plot aridity map
mypal = RColorBrewer::brewer.pal(5, "Spectral") 
terra::plot(aridity, col=mypal, main= "Aridity Spatraster")


# Resample aridity raster to coarse resolution  
aridityResamp=terra::resample(aridity,      # Original raster
                       SMcoarse,            # Target resolution raster
                       method='ngb')        # bilinear or ngb (nearest neighbor) 

# Plot resampled aridity map
terra::plot(aridityResamp, col=mypal, main= "Aridity at Coarser Resolution")

```

### Raster Summary with Polygons

Let's explore using a spatial polygon/shapefile for summarizing a raster (in this case, global SMAP soil moisture) by using `extract` function from the `terra` library.
We will also transform global aridity raster to a polygon using the function `as.polygons` to find the mean soil moisture values for each aridity class.

First, we will use the IPCC shapefile to summarize the soil moisture raster.

```{r, message = FALSE, warning = FALSE}
library(terra) 

# Import SMAP soil moisture raster from the downloaded folder
sm=terra::rast("./SampleData-master/raster_files/SMAP_SM.tif")

# Import the shapefile of global IPCC climate reference regions (only for land) 
IPCC_shp = vect("./SampleData-master/CMIP_land/CMIP_land.shp")

#~~~ Using shapefile to summarize a raster
sm_IPCC_df=terra::extract(sm,        # Spatraster to be summarized
                          IPCC_shp,   # Shapefile/ polygon to summarize the raster
                          fun=mean,   # Desired statistic: mean, sum, min and max 
                          na.rm=TRUE) # Ignore NA values? TRUE=yes! 

head(sm_IPCC_df)

#~~~ Extract cell values for each region 
sm_IPCC_list=terra::extract(sm,       # Raster to be summarized
                          IPCC_shp,   # Shapefile/ polygon to summarize the raster
                          fun=NULL,   # fun=NULL will output cell values within each region
                          na.rm=TRUE) # Ignore NA values? yes! 

# Apply function on cell values for each region
sm_IPCC_mean=lapply(sm_IPCC_list,mean)                       # Returns a list of regional means 
sm_IPCC_mean=purrr::map(sm_IPCC_list,~ mean(.x, na.rm=TRUE)) # Returns a list of regional means

#~~ Try user defined function
myfun=function (y){return(mean(y, na.rm=TRUE))}    # User defined function for calculating means

#~ Implement function using lapply and map
library(purrr)

sm_IPCC_mean=lapply(sm_IPCC_list,myfun)           # Returns a list of regional means 
sm_IPCC_mean=purrr::map(sm_IPCC_list,~ myfun(.x)) # Returns a list of regional means 
sm_IPCC_mean=unlist(sm_IPCC_mean)                 # Unlist to return a vector 

head(sm_IPCC_mean) # Is this the same as the previous result?

```

### Raster Summary with Classified Raster

In the next example, we will convert global aridity raster into a polygon based on aridity classification using `as.polygons` and `st_as_sf` functions.
<br> Global aridity raster has 5 classes with 5 indicating humid and 1 indicating hyper-arid climate.
We will use this polygon to extract values from the `SpatRaster` and summarize soil moisture for each aridity class.

```{r, message = FALSE, warning = FALSE}
#~~~ Convert a raster to a shapefile
aridity=rast("./SampleData-master/raster_files/aridity_36km.tif") #Global aridity

# Convert raster to shapefile
arid_poly=as.polygons(aridity)   # Convert SpatRaster to polygon and then to sf

# Plot aridity polygon
terra::plot(arid_poly, 
     col=arid_poly$aridity_36km)  # Colors based on aridity values (i.e. 1,2,3,4,5)
```

Summarize values of SMAP soil moisture raster for aridity classes:

```{r, message = FALSE, warning = FALSE}
sm_arid_df=terra::extract(sm,        # Raster to be summarized
                          arid_poly, # Shapefile/ polygon to summarize the raster
                          fun=mean,  # Desired statistic: mean, sum, min and max 
                          na.rm=TRUE)# Ignore NA values? yes! 

# Lets plot the climate-wise mean of surface soil moisture
plot(sm_arid_df,     
     xaxt = "n",              # Disable x-tick labels
     xlab="Aridity",          # X axis label
     ylab="Soil moisture",    # Y axis label
     type="b",                # line type
     col="blue",              # Line color
     main="Climate-wise mean of surface soil moisture")
axis(1, at=1:5, labels=c("Hyper-arid", "Arid", "Semi-Arid","Sub-humid","Humid"))

```

More details on arith-generic can be found here: <https://rdrr.io/cran/terra/man/arith-generic.html>
